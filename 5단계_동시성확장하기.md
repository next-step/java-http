# 🚀 5단계 - 동시성 확장하기

## 기능 요구사항
### 1. Executors로 Thread Pool 적용
Connector 클래스의 void process(final Socket connection) 메서드에서 요청마다 스레드를 새로 생성하고 있다.
Connector 클래스에서 Executors 클래스를 사용해서 ExecutorService 객체를 만들어보자.
스레드 갯수는 maxThreads라는 변수로 지정한다.
```java
// maxThreads를 추가했다.
public Connector(final Container container, final int port, final int acceptCount, final int maxThreads) {
    // 생성자에서 스레드 풀 생성
}
```

- 생각해보기 🤔
acceptCount와 maxThreads는 각각 어떤 설정일까?
최대 ThradPool의 크기는 250, 모든 Thread가 사용 중인(Busy) 상태이면 100명까지 대기 상태로 만들려면 어떻게 할까?

```markdown
- acceptCount: core thread 수 이상의 요청일 들어올 때 대기하게 되는 queue 의 capacity
- maxThreads: 요청을 처리할 thread 최대 값
```
```java
ExecutorService executorService = new ThreadPoolExecutor(
            200,
            250, // maxThreads
            0L,
            TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(100) // acceptCount
        );
```

[x] maxThreadPool, coreThreadPool, queueCapacity 를 설정한 ExecuterService 를 적용한다

### 2. 동시 컬렉션 사용하기
SessionManager 클래스에서 Session 컬렉션은 여러 스레드가 동시에 접근할 수 있다.
그러다보니 Session 컬렉션에 여러 스레드가 동시에 접근하여 읽고 쓰다보면 스레드 안정성을 보장하기 어렵다.
동시성 컬렉션(Concurrent Collections)을 적용해서 스레드 안정성과 원자성을 보장해보자.

[x] SessionManager 에서 동시성 컬렉션을 적용한다
```java
private static final Map<String, HttpSession> SESSIONS = new ConcurrentHashMap<>();
```